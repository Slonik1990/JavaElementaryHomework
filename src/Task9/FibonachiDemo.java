package Task9;


public class FibonachiDemo {
    private static int[] cache = new int[1000001];

    /**
     * реализация вычисления числа фибоначчи с помощью рекурсии
     * очень высокая временная сложность алгоритма - О(2^n), числа Фибоначчи с индексом выше 40 расчитываются больше секунды
     * что уже медленно, а после 48 происходит экспоненциарный взрыв, при котором каждое следуещее число расчитывается
     * гораздо дольше предыдущего
     * 48 - 19 сек
     * 49 - 30 сек
     * 50 - 43 сек
     * 51 - 80 сек
     */
    public static int fibRecurs(int index) {
        if (index == 0) return 0;
        if (index == 1 || index == 2) return 1;
        else return fibRecurs(index - 1) + fibRecurs(index - 2);
    }


    /**
     * реализация вычисления числа фибоначчи с помощью цикла
     * <p>
     * Выполняется за линейное время, т.к. растет прямопропорционально росту входных данных
     * Считает очень быстро даже для очень большого индекса,
     * но к сожалению считает неправильно из за ограничения в int или long
     */
    public static int fibLoop(int index) {
        if (index == 0) return 0;
        if (index == 1 || index == 2) return 1;
        int result = 0;
        int prev = 1;
        int old = 1;
        for (int i = 3; i <= index; i++) {
            result = prev + old;
            old = prev;
            prev = result;
        }
        return result;
    }


    /**
     * Метод работает на основе рекурсии и дополнительно использует массив для хранения уже расчитаных значений, что
     * значительно ускоряет время вычисления для первого раза, и еще более сокращает для последующих.
     * Сложность алгоритма со временем снижается и стремится к константному и достигнет его когда будет записано в массив максимальное,
     * допустимое им значение. После этого последующий алгоритм сведется к извлечению значения по индексу ячейки.
     *
     *Так же можно проследить влияние кэша на переполнение стека. Если передать в функцию индекс 15000 - произойдет переполнение
     * стека, а если сначала расчитать для числа поменьше, а после для числа 15000 - такой проблемы не будет.
     *
     *Из минусов - затраты памяти.
     */

    public static int fibRecCache(int index) {
        if (index == 0) return 0;
        if (index == 1 || index == 2) return 1;
        if (cache[index] > 1) return cache[index];
        int result = fibRecCache(index - 1) + fibRecCache(index - 2);
        cache[index] = result;
        return result;
    }


    /**
     *Реализация на основе цикла, работающая быстрее чем рекурсивная и дополнительно оптимизированная с помощью
     * использования cache. Наиболее быстрый вариант. Угроза переполнения стека отсутствует.
     *
     * Из минусов - затраты памяти.
     */

    public static int fibLoopCache(int index) {
        if (index == 0) return 0;
        if (index == 1 || index == 2) return 1;
        if (cache[index] > 1) return cache[index];
        int result = 0;
        int prev = 1;
        int old = 1;
        for (int i = 3; i <= index; i++) {
            result = prev + old;
            cache[index] = result;
            old = prev;
            prev = result;
        }
        return result;
    }

}